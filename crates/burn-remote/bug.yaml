
NumericFloat(F32, Add(BinaryOpIr { lhs: TensorIr { id: TensorId { value: 3821 }, shape: [64, 32], status: ReadWrite, dtype: F32 }, rhs: TensorIr { id: TensorId { value: 3823 }, shape: [64, 32], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3824 }, shape: [64, 32], status: NotInit, dtype: F32 } }))
Init(InitOperationIr { out: TensorIr { id: TensorId { value: 3817 }, shape: [1], status: NotInit, dtype: I32 } })
NumericFloat(F32, Mul(BinaryOpIr { lhs: TensorIr { id: TensorId { value: 3824 }, shape: [64, 32], status: ReadWrite, dtype: F32 }, rhs: TensorIr { id: TensorId { value: 3805 }, shape: [64, 32], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3825 }, shape: [64, 32], status: NotInit, dtype: F32 } }))
BaseFloat(SwapDims(SwapDimsOpIr { input: TensorIr { id: TensorId { value: 3619 }, shape: [11616, 32], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3826 }, shape: [32, 11616], status: NotInit, dtype: F32 }, dim1: 0, dim2: 1 }))
Float(F32, Matmul(BinaryOpIr { lhs: TensorIr { id: TensorId { value: 3825 }, shape: [64, 32], status: ReadOnly, dtype: F32 }, rhs: TensorIr { id: TensorId { value: 3826 }, shape: [32, 11616], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3828 }, shape: [64, 11616], status: NotInit, dtype: F32 } }))
BaseFloat(SwapDims(SwapDimsOpIr { input: TensorIr { id: TensorId { value: 3618 }, shape: [64, 11616], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3829 }, shape: [11616, 64], status: NotInit, dtype: F32 }, dim1: 0, dim2: 1 }))
Float(F32, Matmul(BinaryOpIr { lhs: TensorIr { id: TensorId { value: 3829 }, shape: [11616, 64], status: ReadWrite, dtype: F32 }, rhs: TensorIr { id: TensorId { value: 3825 }, shape: [64, 32], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3830 }, shape: [11616, 32], status: NotInit, dtype: F32 } }))
NumericFloat(F32, MulScalar(ScalarOpIr { lhs: TensorIr { id: TensorId { value: 3828 }, shape: [64, 11616], status: ReadWrite, dtype: F32 }, rhs: 2.0, out: TensorIr { id: TensorId { value: 3831 }, shape: [64, 11616], status: NotInit, dtype: F32 } }))
Init(InitOperationIr { out: TensorIr { id: TensorId { value: 3827 }, shape: [1], status: NotInit, dtype: I32 } })
Init(InitOperationIr { out: TensorIr { id: TensorId { value: 3832 }, shape: [1], status: NotInit, dtype: I32 } })
Init(InitOperationIr { out: TensorIr { id: TensorId { value: 3833 }, shape: [1], status: NotInit, dtype: I32 } })
NumericFloat(F32, Mul(BinaryOpIr { lhs: TensorIr { id: TensorId { value: 3831 }, shape: [64, 11616], status: ReadWrite, dtype: F32 }, rhs: TensorIr { id: TensorId { value: 3616 }, shape: [64, 11616], status: ReadWrite, dtype: F32 }, out: TensorIr { id: TensorId { value: 3834 }, shape: [64, 11616], status: NotInit, dtype: F32 } }))
Init(InitOperationIr { out: TensorIr { id: TensorId { value: 3835 }, shape: [28, 28], status: NotInit, dtype: F32 } })

thread 'tokio-runtime-worker' panicked at /Users/guilhemane/tracel/burn/crates/burn-ir/src/handle.rs:78:32:
Should have handle for tensor TensorId { value: 3825 }
stack backtrace:
   0: __rustc::rust_begin_unwind
   1: core::panicking::panic_fmt
   2: burn_ir::handle::HandleContainer<H>::get_handle::{{closure}}
   3: core::option::Option<T>::unwrap_or_else
   4: burn_ir::handle::HandleContainer<H>::get_handle
   5: burn_ir::handle::HandleContainer<H>::get_tensor_handle
   6: burn_ir::handle::HandleContainer<H>::get_float_tensor
   7: <burn_fusion::ops::float::<impl burn_tensor::tensor::ops::tensor::FloatTensorOps<burn_fusion::backend::Fusion<B>> for burn_fusion::backend::Fusion<B>>::float_matmul::MatmulOps<B> as burn_fusion::stream::execution::base::Operation<<B as burn_fusion::backend::FusionBackend>::FusionRuntime>>::execute
   8: burn_fusion::stream::execution::ordering::OrderedExecution<R>::execute_operations
   9: burn_fusion::stream::queue::execution::QueueExecution<R>::execute_strategy
  10: burn_fusion::stream::queue::execution::QueueExecution<R>::execute_strategy
  11: burn_fusion::stream::queue::execution::QueueExecution<R>::run
  12: burn_fusion::stream::queue::execution::<impl burn_fusion::stream::queue::base::OperationQueue<R>>::execute_block_optimization
  13: burn_fusion::stream::queue::execution::<impl burn_fusion::stream::queue::base::OperationQueue<R>>::execute
  14: <burn_fusion::stream::multi::Segment<R> as burn_fusion::stream::execution::processor::StreamSegment<<R as burn_fusion::backend::FusionRuntime>::Optimization>>::execute
  15: burn_fusion::stream::execution::processor::Processor<O>::explore
  16: burn_fusion::stream::execution::processor::Processor<O>::process
  17: burn_fusion::stream::multi::MultiStream<R>::drain
  18: burn_fusion::stream::multi::MultiStream<R>::resolve_stream
  19: burn_fusion::stream::multi::MultiStream<R>::merge_streams_timelines
  20: burn_fusion::stream::multi::MultiStream<R>::resolve_streams
  21: burn_fusion::stream::multi::MultiStream<R>::register
  22: burn_fusion::server::FusionServer<R>::register
  23: <burn_fusion::client::mutex::MutexFusionClient<R> as burn_fusion::client::base::FusionClient<R>>::register
  24: burn_fusion::ops::float::<impl burn_tensor::tensor::ops::tensor::FloatTensorOps<burn_fusion::backend::Fusion<B>> for burn_fusion::backend::Fusion<B>>::float_mul
  25: <burn_router::runner::Runner<B> as burn_router::client::base::RunnerClient>::register
  26: burn_remote::server::processor::Processor<B>::start::{{closure}}::{{closure}}
  27: <core::pin::Pin<P> as core::future::future::Future>::poll
  28: tokio::runtime::task::core::Core<T,S>::poll::{{closure}}
  29: tokio::runtime::task::core::Core<T,S>::poll
  30: tokio::runtime::task::harness::poll_future::{{closure}}
  31: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once
  32: std::panicking::try::do_call
  33: ___rust_try
  34: std::panic::catch_unwind
  35: tokio::runtime::task::harness::poll_future
  36: tokio::runtime::task::harness::Harness<T,S>::poll_inner
  37: tokio::runtime::task::harness::Harness<T,S>::poll
  38: tokio::runtime::task::raw::poll
  39: tokio::runtime::task::raw::RawTask::poll
  40: tokio::runtime::task::LocalNotified<S>::run
  41: tokio::runtime::scheduler::multi_thread::worker::Context::run_task::{{closure}}
  42: tokio::runtime::scheduler::multi_thread::worker::Context::run_task
  43: tokio::runtime::scheduler::multi_thread::worker::Context::run
  44: tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}::{{closure}}
  45: tokio::runtime::context::scoped::Scoped<T>::set
  46: tokio::runtime::context::set_scheduler::{{closure}}
  47: std::thread::local::LocalKey<T>::try_with
  48: std::thread::local::LocalKey<T>::with
  49: tokio::runtime::context::set_scheduler
  50: tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}
  51: tokio::runtime::context::runtime::enter_runtime
  52: tokio::runtime::scheduler::multi_thread::worker::run
  53: tokio::runtime::scheduler::multi_thread::worker::Launch::launch::{{closure}}
  54: <tokio::runtime::blocking::task::BlockingTask<T> as core::future::future::Future>::poll
  55: tokio::runtime::task::core::Core<T,S>::poll::{{closure}}
  56: tokio::runtime::task::core::Core<T,S>::poll
  57: tokio::runtime::task::harness::poll_future::{{closure}}
  58: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once
  59: std::panicking::try::do_call
  60: ___rust_try
  61: std::panic::catch_unwind
  62: tokio::runtime::task::harness::poll_future
  63: tokio::runtime::task::harness::Harness<T,S>::poll_inner
  64: tokio::runtime::task::harness::Harness<T,S>::poll
  65: tokio::runtime::task::raw::poll
  66: tokio::runtime::task::raw::RawTask::poll
  67: tokio::runtime::task::UnownedTask<S>::run
  68: tokio::runtime::blocking::pool::Task::run
  69: tokio::runtime::blocking::pool::Inner::run
  70: tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.

thread 'tokio-runtime-worker' panicked at /Users/guilhemane/tracel/burn/crates/burn-router/src/runner.rs:153:43:
called `Result::unwrap()` on an `Err` value: "poisoned lock: another task failed inside"
stack backtrace:
   0: __rustc::rust_begin_unwind
   1: core::panicking::panic_fmt
   2: core::result::unwrap_failed
   3: <burn_router::runner::Runner<B> as burn_router::client::base::RunnerClient>::register
   4: burn_remote::server::processor::Processor<B>::start::{{closure}}::{{closure}}
   5: <core::pin::Pin<P> as core::future::future::Future>::poll
   6: tokio::runtime::task::core::Core<T,S>::poll::{{closure}}
   7: tokio::runtime::task::core::Core<T,S>::poll
   8: tokio::runtime::task::harness::poll_future::{{closure}}
   9: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once
  10: std::panicking::try::do_call
  11: ___rust_try
  12: std::panic::catch_unwind
  13: tokio::runtime::task::harness::poll_future
  14: tokio::runtime::task::harness::Harness<T,S>::poll_inner
  15: tokio::runtime::task::harness::Harness<T,S>::poll
  16: tokio::runtime::task::raw::poll
  17: tokio::runtime::task::raw::RawTask::poll
  18: tokio::runtime::task::LocalNotified<S>::run
  19: tokio::runtime::scheduler::multi_thread::worker::Context::run_task::{{closure}}
  20: tokio::runtime::scheduler::multi_thread::worker::Context::run_task
  21: tokio::runtime::scheduler::multi_thread::worker::Context::run
  22: tokio::runtime::scheduler::multi_thread::worker::run::{{closure}}::{{closure}}
  23: tokio::runtime::context::scoped::Scoped<T>::set
  